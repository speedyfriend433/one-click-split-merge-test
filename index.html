<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>One-Click PNG Split & Merge</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #drop-area {
      border: 2px dashed #ccc;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
    }
    #results {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>One-Click PNG Split & Merge</h1>
  <p>Upload a ZIP file (with PNG and plist) or select a PNG file and a plist file.</p>
  <div id="drop-area">
    <input type="file" id="fileInput" multiple>
  </div>
  <div id="results"></div>

  <!-- Include JSZip (for extracting ZIP files) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Include plist parser -->
  <script src="https://cdn.jsdelivr.net/npm/plist@3.0.1/dist/plist.min.js"></script>
  <script>
    // Global variables to hold our source files
    let sourcePNGFile = null;
    let sourcePlistFile = null;

    const fileInput = document.getElementById('fileInput');
    const resultsDiv = document.getElementById('results');

    fileInput.addEventListener('change', handleFiles, false);

    async function handleFiles(event) {
      // Reset any previously stored files
      sourcePNGFile = null;
      sourcePlistFile = null;
      resultsDiv.innerHTML = '';

      const files = event.target.files;
      if (!files.length) return;

      // If a ZIP is provided, try to extract it
      for (const file of files) {
        if (file.name.toLowerCase().endsWith('.zip')) {
          await processZip(file);
          break; // only process one ZIP at a time
        }
      }
      // If not ZIP, then check for separate PNG and plist
      if (!sourcePNGFile || !sourcePlistFile) {
        for (const file of files) {
          if (file.name.toLowerCase().endsWith('.png')) {
            sourcePNGFile = file;
          } else if (file.name.toLowerCase().endsWith('.plist')) {
            sourcePlistFile = file;
          }
        }
      }

      if (!sourcePNGFile || !sourcePlistFile) {
        resultsDiv.innerHTML = '<p style="color:red;">Please upload both a PNG file and its corresponding plist file (or a ZIP containing both).</p>';
        return;
      }

      // Process the PNG and plist
      processFiles();
    }

    async function processZip(zipFile) {
      const jszip = new JSZip();
      try {
        const zip = await jszip.loadAsync(zipFile);
        // Look for PNG and plist files inside the zip
        for (const filename in zip.files) {
          const fileObj = zip.files[filename];
          if (!fileObj.dir) {
            if (filename.toLowerCase().endsWith('.png') && !sourcePNGFile) {
              const blob = await fileObj.async("blob");
              sourcePNGFile = new File([blob], filename, { type: blob.type });
            } else if (filename.toLowerCase().endsWith('.plist') && !sourcePlistFile) {
              const content = await fileObj.async("string");
              sourcePlistFile = new File([content], filename, { type: "text/plain" });
            }
          }
        }
      } catch (e) {
        resultsDiv.innerHTML = `<p style="color:red;">Error processing ZIP file: ${e.message}</p>`;
      }
    }

    async function processFiles() {
      try {
        // Read the plist file as text
        const plistText = await readFileAsText(sourcePlistFile);
        // Parse the plist into a JavaScript object.
        // (This assumes the plist structure has a top-level "frames" dictionary.
        // Adjust as needed for your plist.)
        const plistData = window.plist.parse(plistText);
        if (!plistData.frames) {
          resultsDiv.innerHTML = '<p style="color:red;">Plist file does not contain a "frames" key.</p>';
          return;
        }
        const frames = plistData.frames;

        // Load the PNG image into an HTMLImageElement
        const imgURL = URL.createObjectURL(sourcePNGFile);
        const img = await loadImage(imgURL);

        // Create a hidden canvas to extract subimages
        const tempCanvas = document.createElement('canvas');
        const tctx = tempCanvas.getContext('2d');
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tctx.drawImage(img, 0, 0);

        // For demonstration, we’ll create an array of canvases for each frame.
        // We assume each frame entry in the plist has a name and a frame rectangle.
        // (The structure depends on your plist format. For example, many plist files
        // generated by texture packers use a string like "{{x,y},{w,h}}".)
        const frameCanvases = [];
        for (const frameName in frames) {
          const frameInfo = frames[frameName];
          // Parse the frame rectangle.
          // Here we assume frameInfo.frame is a string like "{{x,y},{w,h}}"
          const rect = parseFrameString(frameInfo.frame);
          if (!rect) continue;
          // Create a canvas for this frame.
          const fCanvas = document.createElement('canvas');
          fCanvas.width = rect.w;
          fCanvas.height = rect.h;
          const fctx = fCanvas.getContext('2d');
          // Draw the subimage using drawImage (source image, sx, sy, sw, sh, dx, dy, dw, dh)
          fctx.drawImage(img, rect.x, rect.y, rect.w, rect.h, 0, 0, rect.w, rect.h);
          frameCanvases.push(fCanvas);
        }

        // --- Merge Process ---
        // For this demo, we “merge” by laying out all frames in a grid.
        const cols = Math.ceil(Math.sqrt(frameCanvases.length));
        const rows = Math.ceil(frameCanvases.length / cols);
        // Determine maximum frame width/height to size the grid cells
        let cellW = 0, cellH = 0;
        frameCanvases.forEach(c => {
          cellW = Math.max(cellW, c.width);
          cellH = Math.max(cellH, c.height);
        });
        const mergedCanvas = document.createElement('canvas');
        mergedCanvas.width = cols * cellW;
        mergedCanvas.height = rows * cellH;
        const mctx = mergedCanvas.getContext('2d');
        // Optional: fill background
        mctx.fillStyle = "#fff";
        mctx.fillRect(0, 0, mergedCanvas.width, mergedCanvas.height);

        // Draw each frame into the merged canvas grid.
        frameCanvases.forEach((c, index) => {
          const col = index % cols;
          const row = Math.floor(index / cols);
          mctx.drawImage(c, col * cellW, row * cellH);
        });

        // Create a download link for the merged image.
        mergedCanvas.toBlob(function(blob) {
          const mergedURL = URL.createObjectURL(blob);
          resultsDiv.innerHTML = `
            <h2>Output Image</h2>
            <img src="${mergedURL}" alt="Merged Image" style="max-width: 100%;"><br>
            <a href="${mergedURL}" download="${sourcePNGFile.name}" style="font-size:16px;">Download Merged Image</a>
          `;
        }, sourcePNGFile.type);

      } catch (err) {
        resultsDiv.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
      }
    }

    // Utility: read a File as text
    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    // Utility: load an image from a URL
    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }

    // Utility: Parse a frame string like "{{x,y},{w,h}}"
    // Returns an object {x, y, w, h} or null on failure.
    // Utility: Parse a frame string like "{{x,y},{w,h}}"
function parseFrameString(str) {
  // Ensure the string is valid and contains the expected format
  if (!str || typeof str !== 'string') {
    console.error("Invalid frame string:", str);
    return null;
  }

  // Remove curly braces and spaces, then split by comma
  const cleaned = str.replace(/[{}]/g, '').trim();
  
  // Check if the cleaned string contains 4 numeric values
  const parts = cleaned.split(',');
  if (parts.length !== 4) {
    console.error("Incorrect frame format:", cleaned);
    return null;
  }

  // Parse values as numbers
  const [x, y, w, h] = parts.map(parseFloat);

  // Ensure all parsed values are valid numbers
  if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {
    console.error("Invalid frame values:", x, y, w, h);
    return null;
  }

  // Return the parsed rectangle object
  return { x, y, w, h };
}
  </script>
</body>
</html>
