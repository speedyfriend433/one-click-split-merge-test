<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>One Click Split-Merge</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pica/6.0.0/pica.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/plist/3.0.1/plist.min.js"></script>
  <style>
    #output { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>One Click PNG Split/Merge</h1>
  <input type="file" id="inputFile" accept=".zip" />
  <div id="output"></div>
  <script>
    document.getElementById('inputFile').addEventListener('change', handleFileUpload, false);

    async function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const zip = await JSZip.loadAsync(file);
      const plistFile = zip.file(/\.plist$/)[0];
      const pngFiles = zip.file(/\.png$/);

      if (!plistFile) {
        alert("No plist file found in ZIP!");
        return;
      }

      const plistData = await plistFile.async('text');
      const plist = plist.parse(plistData);
      const images = await loadPngImages(pngFiles);

      const mergedCanvas = await mergeImages(images, plist);
      displayMergedCanvas(mergedCanvas);
    }

    async function loadPngImages(pngFiles) {
      const images = [];
      for (const file of pngFiles) {
        const imgData = await file.async('blob');
        const img = await createImageBitmap(imgData);
        images.push(img);
      }
      return images;
    }

    async function mergeImages(images, plist) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      let maxWidth = 0;
      let totalHeight = 0;

      // First, determine the final size of the canvas based on the frames
      plist.frames.forEach(frameInfo => {
        if (!frameInfo.frame) {
          console.error("Missing frame data for:", frameInfo);
          return;
        }

        const frame = parseFrameString(frameInfo.frame);
        if (!frame) return;

        maxWidth = Math.max(maxWidth, frame.x + frame.w);
        totalHeight = Math.max(totalHeight, frame.y + frame.h);
      });

      canvas.width = maxWidth;
      canvas.height = totalHeight;

      // Now, draw the images into the canvas based on the frames
      plist.frames.forEach((frameInfo, index) => {
        if (!frameInfo.frame) {
          console.error("Missing frame data for:", frameInfo);
          return;
        }

        const frame = parseFrameString(frameInfo.frame);
        if (!frame) return;

        ctx.drawImage(images[index], frame.x, frame.y, frame.w, frame.h);
      });

      return canvas;
    }

    // Utility: Parse a frame string like "{{x,y},{w,h}}"
    function parseFrameString(str) {
      if (!str || typeof str !== 'string') {
        console.error("Invalid frame string:", str);
        return null;
      }

      const cleaned = str.replace(/[{}]/g, '').trim();
      const parts = cleaned.split(',');
      if (parts.length !== 4) {
        console.error("Incorrect frame format:", cleaned);
        return null;
      }

      const [x, y, w, h] = parts.map(parseFloat);

      if (isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h)) {
        console.error("Invalid frame values:", x, y, w, h);
        return null;
      }

      return { x, y, w, h };
    }

    function displayMergedCanvas(mergedCanvas) {
      const resultsDiv = document.getElementById('output');
      mergedCanvas.toBlob(function(blob) {
        const mergedURL = URL.createObjectURL(blob);
        resultsDiv.innerHTML = `
          <h2>Output Image</h2>
          <img src="${mergedURL}" alt="Merged Image" style="max-width: 100%;"><br>
          <a href="${mergedURL}" download="merged_image.png" style="font-size:16px;">Download Merged Image</a>
        `;
      }, 'image/png');
    }
  </script>
</body>
</html>
